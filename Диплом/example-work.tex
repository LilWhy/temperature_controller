\documentclass[bachelor, och, diploma, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{дискретной математики и информационных технологий}

% Тема работы
\title{Реализация системы мониторинга технологического процесса с использованием интернета умных вещей}

% Курс
\course{4}

% Группа
\group{421}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Лаптева Юрия Владиславовича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{Л.\,Б.\,Тяпаев}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{А.\,Д.\,Панфёров}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{к.\,ф.-м.\,н., доцент}
\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.07.2016}
\practFinish{14.07.2016}

% Год выполнения отчета
\date{2021}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
	За последние годы технологии продвинулись далеко вперед. Были открыты новые направления как в промышленности, так и в ИТ сфере. Одной из ключевых концепций, позволивших расширить возможности технологических процессов является Интернет вещей.
	
	Интернет вещей (IoT) - концепция, объединения различных устройств посредством как беспроводных технологий, так и через интернет. Устройства могут обмениваться информацией как при участии человека, так и без какого-либо вмешательства. Развитие концепции Интернета вещей произошло благодаря широкому распространению беспроводных сетей, смартфонов, ноутбуков.
	
	Применение устройств из категории Интернета вещей так же получило распространение и в производстве. Были изобретены системы удаленного мониторинга с различными возможностями, требуемыми в конкретной отрасли. 
	
	Устройства из категории Интернет вещей можно найти и в ювелирном деле. Так появились устройства, способные точно и быстро вырезать необходимые заготовки из ювелирного воска по загруженным удаленно с ноутбука 3D моделям, лазерные установки, способные как выжигать сложные элементы на металле, так и прожигать его. Так же существуют контролеры для работы с муфельными печами. Данные устройства позволяют отслеживать и корректировать температуру внутри изолированного короба.
	
	Муфельные печи появились в конце XVII - начале XVIII вв. и представляли собой контейнер (муфель), устойчивый к высоким температурам и имеющий непроницаемую для отвода тепла структуру.С увеличением масштабов производства необходимость таких конструкций значительно возросло.
	
	В современном мире муфельные печи получили системы контроля температуры и времени работы. На рынке представлено широкий ассортимент систем мониторинга таких как: механический контролеры температуры печи, автоматические регуляторы муфельной печи.
	
	На данный момент не существует гибко настраиваемых систем мониторинга для муфельных печей с возможностью дистанционного управления через WEB интерфейс.
	
	Целью данной выпускной квалификационной работы является разработка системы мониторинга технологического процесса со следующими функционалом: поддержание определенной температуры в течении установленного периода времени(так называемых "температурных полок"), сбор, хранение и показ статистики о температуре и времени ее  поддержания при работе устройства, удаленное создание и редактирование температурных полок.
	
	Для реализации данной цели было необходимо решить следующие задачи:
\begin{itemize}
\item изучить общие положения концепции Интернета вещей;
\item изучить представленные на рынке системы мониторинга для муфельных печей;
\item разработать конструкцию муфельной печи, способную сохранять целостность при высоких температурах;
\item изучить электронные компоненты, способные работать длительное время под нагрузками;
\item продумать и разработать клиентскую и серверную часть приложения;
\end{itemize}
\section{Общие сведения о предметной области}
В данном разделе будут рассмотрены общие концепция Интернета умных вещей, история появления, развитие данной концепции. Также будут рассмотрены различные конфигурации систем мониторинга для муфельных печей и их основные различия.
	\subsection{Интернет умных вещей}
		Интернет вещей (IoT) - концепция, объединения различных устройств посредством как беспроводных технологий, так и через интернет. Устройства могут обмениваться информацией как при участии человека, так и без какого-либо вмешательства. Развитие концепции Интернета вещей произошло в 2008 - 2009 годах благодаря широкому распространению беспроводных сетей, смартфонов, ноутбуков.
		
		Термин <<Интернет вещей>> появился в 1999 году когда сотрудник Procter n Gamble Кевин Эштон предложил использовать радиочастотные метки для оптимизации логистики корпорации. Для изучения данной концепции в Массачусетском технологическом институте был создан Центр автоматической идентификации.
		
	Одним из главных направлений в развитии Интернета вещей можно считать Промышленный Интернет вещей. Это система подключенных компьютерных сетей и подключенных к ним производственных объектов с различными встроенными датчиками и специализированным программным обеспечением, позволяющим не только собирать и анализировать данные, но и удаленно управлять устройствами. Также в таких системах может использоваться полностью автоматическое управление без участия человека.
	\subsubsection{Как устроен Промышленный Интернет вещей}
	При внедрении концепции Промышленного Интернета вещей на оборудование устанавливаются различные датчики, управляемые электронно механизмы, контроллеры и различные интерфейсы для взаимодействия человека с машинами. В результате появляется возможность собирать и анализировать получаемые данные. Обработанные данные поступают на сервера, откуда доступны для просматривания и анализа уже людьми. 
	
	Такой сбор данных помогает предотвращать внеплановые простои, поломки оборудования, сбои в управлении, тем самым позволяя предприятию функционировать более эффективно.
	
	Уже сейчас появляются различные цифровые экосистемы, которые позволяют предприятиям объединять различные участки рынка, что в свою очередь позволяет комплексно подходить к анализу и грамотнее распределять производственные ресурсы.
	\subsection{Системы мониторинга для муфельных печей и их применение}
	В данном разделе будут рассмотрены основные конфигурации систем мониторинга для муфельных печей. их ключевые особенности, их плючы и минусы, и их применение.
	
	Базовой функцией для каждой системы мониторинга для муфельных печей можно считать поддержание определенной температуры в течении заданного времени. Все описанные ниже системы способны удерживать так называемые температурные полки, но отличаются количеством их установок.
	
	На рынке существует несколько видов систем мониторинга для муфельных печей:
	\begin{itemize}
	\item механический контроллер температуры печи;
	\item автоматический регулятор муфельной печи;
	\item ПИД-контроллер-программатор для муфельной печи;
	\end{itemize}
	\subsubsection{Механический контроллер температуры печи}
	Данный класс системы мониторинга предназначен для поддерживания заданной температуры на протяжении всего времени, выставленного на таймере. Механический контроллер представляет собой термопару, подключенную к простому контроллеру, зачастую с возможностью выставления лишь одной поддерживаемой температуры на выставленное время. К плюсам данного класса устройств можно отнести:
		\begin{itemize}
		\item простота в использовании;
		\item долговечность;
		\end{itemize}
	К минусам таких устройств можно отнести:
			\begin{itemize}
			\item обязательное присутствие человека;
			\item зачастую невозможность установки больше чем одной температурной полки;
			\item невозможность передачи информации на удаленные устройства;
			\end{itemize}
			На рисунке \ref{re1} представлен общий вид класса данных устройств.
			\begin{figure}[!ht]
				\centering
				\includegraphics[width=6cm]{1.jpg}
				\caption{\label{re1}%
				Общий вид механических контроллеров для муфельной печи}
			\end{figure}
			Данный вид контроллеров невозможно отнести к Интернету вещей, так как процесс не автоматизирован и требует постоянного участия человека.
	\subsubsection{Автоматический регулятор муфельной печи}
	Данный класс системы мониторинга является улучшенной версией предыдущего класса устройств. Автоматический регулятор муфельной печи имеет уже микроконтроллер для более точного измерения температуры. Также данная система имеет возможность выставления нескольких необходимых температурных значений. К плюсам данного класса устройств можно отнести: 
	\begin{itemize}
			\item возможность выставления нескольких необходимых темпертурных значений;
			\item проведение высокоточных температурных измерений по всей площади камеры;
			\item отсутствие необходимости нахождения рядом человека;
			\end{itemize}
		К минусам таких устройств можно отнести:
				\begin{itemize}
				\item невозможность составления прогнозов и недопущение повторения ошибок;
				\item невозможность передачи информации на удаленные устройства;
				\end{itemize}
				
			На рисунке \ref{re2} представлен общий вид класса данных устройств.
			\begin{figure}[!ht]
				\centering
				\includegraphics[width=6cm]{2.jpg}
				\caption{\label{re2}%
				Общий вид автоматических регуляторов муфельной печи}
			\end{figure}
			Данный класс систем мониторинга можно частично отнести к Интернету вещей, так как процесс автоматизирован и не требует вмешательства человека, но для реализации поставленной в рамках выпускной квалификационной работы бакалавра уели не подходит, так как не имеет возможности интеграции с удаленными серверами.
	\subsubsection{ПИД-контроллер-программатор для муфельной печи}
	Данный класс систем мониторинга является самым востребованным на сегодняшний день. Работа данных устройств строится отследивании состояния муфельной печи и образование немедленных соответствующих сигналов на управляющие устройства. Зачастую, данные устройства имеют на борту 2 дисплея, показывающие как установленную температуру, так и текущую. К плюсам данного класса устройств можно отнести: 
		\begin{itemize}
				\item немедленное реагирование на текущий процесс с возможностью устранения неточностей;
				\item оценка отклонения, происходящих на всем периоде работы;
				\item отсутствие необходимости нахождения рядом человека;
				\item наличие инструментов для удаленной работы с устройствами;
				
				\end{itemize}
			К минусам таких устройств можно отнести:
					\begin{itemize}
					\item программирование таких устройств достаточно трудоемкое занятие, так как нужно обладать как специальными знаниями, так и специализированными инструментами
					\end{itemize}
					
				На рисунке \ref{re3} представлен общий вид класса данных устройств.
				\begin{figure}[!ht]
					\centering
					\includegraphics[width=6cm]{3.jpg}
					\caption{\label{re3}%
					Общий вид ПИД-контроллеров-программаторов для муфельной печи}
				\end{figure}
				Данный класс систем полностью соответствует концепции Промышленного Интернета вещей.
				
				Для реализации цели выпускной квалификационной работы было принято решение использовать одноплатный микрокомпьютер, подходящий для реализации концепции данного типа устройств.
	
\section{Сведения о конфигурации системы мониторинга технологического процесса}
В данном разделе будут рассмотрены основные компоненты, использованные в рамках выпускной квалификационной работы, и общая схема подключения.
	\subsection{Однопалатный компьютер PrangePi One}
Orange Pi One — одноплатный микрокомпьютер с четырех-ядерным процессором ARM Cortex-A7 H3. Имеет четырех-ядерный процессор Cortex-A7 с частотой 1.2ГГц, видео ядро Mali 400MP2 (600 МГц). В Orange Pi One доступно 512 МБ DDR3 ОЗУ. С каждой стороны платы находится по чипу производства Samsung  объемом по 256 МБ. Данный одноплатный микрокомпьютер имеет слот карты памяти, поддерживаемый до 64 Гб, используемый в качестве основной памяти.Есть порт Ethernet со скоростью до 100 Мб/с. Главной особенностью одноплатных компьютеров является наличие 40 пинов, которыми можно програмно управлять, что и было использовано в дальнейшем.

Orange Pi One поддерживает широкий набор операционных систем: Android, Ubuntu, Armbian, ArchLinux, Gentoo, OpenSUSE, Kali, Fedora, Rasberry Pi Image. Мною была выбрана операционная система Armbian, так как данная ОС  отличается быстротой работы и возможностью взаимодействия с GPIO пинами.

Данный элемент выполняет функцию гибко настраиваемого управляющего контроллера, подключенного посредством Ethernet к WI-FI роутеру для взаимодействия с микрокомпьютером из любой точки мира. Он подает сигналы, включающие и выключающие твердотельное реле SSR-25DA, сбор информации с термопары К-типа и модуля преобразователя термопары MAX6675, для вывода информации о текущей температуре внутри муфельной печи и заданной в WEB приложении требуемой температуры. На микрокомпьютере находится вся серверная и клиентская части приложения. 

На официальном сайте микрокомпьютеров Orange Pi есть вся необходимая информация по запуску и настройке устройства. Для полноценной работы с микрокомпьютером необходимы следующие элементы:
\begin{itemize}
\item TransFlash-карта (далее TF-карта) класса 10 для записи на нее образа операционной системы, устанавливаемой на микрокомпьютер. Класс показывает, как быстро работает карта. 10 класс является самым быстрым у TF-карт, он подходит даже для для записи Full HD в формате RAW, просмотра фильмов и прохождения игр на планшете или ноутбуке. Минимальный требуемый размер TF-карты – 8 гигабайтов;
\item Ethernet кабель для подключения одноплатного микрокомпьютера к WI-FI роутеру;
\item лабораторный блок питания, выставленный на 5V и 2A для питания Orange PI;
\end{itemize}

На рисунке \ref{re4} представлен одноплатный компьютер Orange Pi One.
				\begin{figure}[!ht]
					\centering
					\includegraphics[width=8cm]{4.jpg}
					\caption{\label{re4}%
					Одноплатный компьютер Orange Pi One}
				\end{figure}
В выпускной квалификационной работе мною были использованы следующие GPTO выходы для следующих электронных компонентов:
\begin{itemize}
\item для твердотельного реле SSR-25DA были задействованы пины 39 и 40;
\item для термопары К-типа и модуля преобразователя термопары MAX6675 были задействованы пины  17, 20, 21, 22,23;
\item для дисплея SPI 1602 LCD были использованы 2, 3, 5, 6;
\end{itemize}
В дальнейшем будут рассмотрено функциональное назначение каждого из использованных GPIO  выходов.

На рисунке \ref{re5} можно посмотреть GPIO выходы одноплатного микрокомпьютера Orange Pi One.
				\begin{figure}[!ht]
					\centering
					\includegraphics[width=6cm]{5.png}
					\caption{\label{re5}%
					Одноплатный компьютер Orange Pi One}
				\end{figure}
\subsection{Твердотельное реле SSR-25DA}
Твердотельное реле SSR-25DA - полупроводниковое реле, предназначено для бесконтактной коммутации осветительных приборов, нагревательных элементов и других устройств с переменным напряжением питания от 24 до 480 В. Данный прибор не требует пайки, так как имеет винтовые разъемы, для подключения проводов. Твердотельные реле имеет много преимуществ перед электромеханическими реле: низкий уровень помех за счет встроенного детектора нуля, возможность управлять напрямую с выводов контроллера, гораздо больший эксплуатационный ресурс, высокое быстродействие, отсутствие механической контактной группы, бесшумность, небольшие размеры, гальваническая развязка от управляющей цепи и высокая надежность. Из удобств стоит отметить возможность подключения без паяльника, так как все разъемы выполнены под винтовой зажим. Реле SSR можно без опасения подключать напрямую к выводам микроконтроллеров и одноплатных компьютеров, так как в этом электронном реле есть гальваническая развязка с силовым блоком.

Данное реле было использовано в выпускной квалификационной работе для взаимодействия с нагревательным элементом внутри муфельной печи. Оно выполняет функцию отключения и включения тока внутри цепи.

На рисунке \ref{re6} изображено твердотельное реле SSR-25DA.
				\begin{figure}[!ht]
					\centering
					\includegraphics[width=6cm]{6.jpg}
					\caption{\label{re6}%
					Твердотельное реле SSR-25DA}
				\end{figure}
	\subsection{Термопара К-типа и модуль аналого-цифрового преобразования MAX6675}
	Термопара К-типа представляет собой соединение из хромеля (сплава хрома и никеля с примесями кремния, меди, марганца, кобальта) и алюминия. Принцип действия термопары основан на том, что нагревание или охлаждение контактов между проводниками, отличающимися химическими или физическими свойствами, сопровождается возникновением термоэлектродвижущей силы. Данный вид термопар предназначен для замера температур до 1000 градусов. Выходным сигналом сенсора К — типа служит постоянное напряжение, пропорционально зависящее от температуры в точке состыковки контактов термопары. Так как выходные сигналы термопары аналоговые, было принято решение использовать аналого-цифровой преобразователь MAX6675 с копменсацией холодного спая.
	
	На модуле MAX6675 установлена одна микросхема MAX6675ISA фирмы Maxim Integrated Products конденсатор и пару разъемов. Микросхема имеет 12 битный АЦП, SPI интерфейс и точность микросхема 0,25 градусов.
	
	Для подключения модуля MAX6675 к микроконтроллеру используется шина SPI, для этого на модуле выведены пять контактнов, назначение каждого вывода приведено ниже.
	\begin{itemize}
	\item GND - минусовое питание модуля;
	\item VCC - плюсовое питание модуля;
	\item SCK - тактовые импульсы;
	\item SC - вывод интерфейса SPI;
	\item SO - вывод интерфейса SPI;
	\end{itemize}
	
	На рисунке \ref{re7} представлена термопара К-типа и модуль аналого-цифрового преобразования MAX6675.
	
	\begin{figure}[!ht]
		\centering
		\includegraphics[width=6cm]{7.jpg}
		\caption{\label{re7}%
	 Термопара К-типа и модуль аналого-цифрового преобразования MAX6675}
	\end{figure}	
	\subsection{Дисплей I2C 1602 LCD}
	Дисплей I2C 1602 LCD - это жидкокристаллический, текстовый, двух строчный, 16 знакомест в каждой строке, цифровой I2C индикатор с подсветкой. Каждое знакоместо имеет разрешение 8 x 5 точек. Общее количество точек экрана 1280 пикселей. В память устройства встроено 192 знака, еще 8 знаков может определить сам пользователь. Дисплей основан на контроллере HD44780 и предназначен для отображения любой текстовой информации. Благодаря дополнительно установленному I2C модулю расширения портов на микросхеме PCF85741, диплей стал занимать гораздо меньше портов управления GPIO на одноплатном микрокомпьютере Orange Pi One.
	
	 	Для подключения модуля I2C 1602 LCD к микроконтроллеру используется шина I2C, для этого на модуле выведены четыре контактна, назначение каждого вывода приведено ниже.
	 	\begin{itemize}
	 	\item GND - минусовое питание модуля;
	 	\item VCC - плюсовое питание модуля;
	 	\item SCL - тактовые импульсы;
	 	\item SDA - вывод интерфейса I2C;
	 	\end{itemize}	
	\subsection{Общая схема подключения}
	Для корректной работы свей системы в целом и отдельных ее элементов необходимо правильно подключить все компоненты из которых состоит система мониторинга технологического процесса. 
	
	На рисунку \ref{re8} показана общая схема подключения всех электрических модулей.
	
	\begin{figure}[!ht]
		\centering
		\includegraphics[scale=0.9]{8.jpg}
		\caption{\label{re8}%
 Общая схема подключения электрических компонентов}
	\end{figure}
	
	Подключение всех электрических компонентов производилось при помощи соединительных проводов.
		
\section{Теоретические сведения об используемых в разработке технологиях}
В реализованной версии системы мониторинга технологического процесса клиентской частью приложения является WEB интерфейс, написанный на языках HTML  и JavaScript. Для серверной части приложения был использован язык Python. Обе части приложения находятся на одноплатном микрокомпьютере Orange Pi One. Клиентская часть позволяет как наблюдать за процессами, происходящими внутри муфельной печи на расстоянии, так и настраивать температурные режимы. Серверная часть отвечает за обработку запросов, происходящих на клиентской части приложения, их обработку и своевременное взаимодействие с электрическими составляющими системы.

В данном разделе описываются технологии, примененные в рамках выпускной квалификационной работы бакалавра.
	\subsection{Клиент-серверная архитектура}
	Архитектура разработанного приложения представляет собой WEB-приложение.
	
	WEB-приложение – это клиент-серверное приложение, в котором браузер выступает клиентом, а сервером – WEB-сервер. Основная часть приложения, находится на стороне WEB-сервера, который обрабатывает полученные запросы в соответствии с бизнес-логикой продукта и формирует ответ, отправляемый пользователю. На этом этапе в работу включается браузер, именно он преобразовывает полученный ответ от сервера в графический интерфейс, понятный пользователю.
	\subsection{Серверная часть приложения}
	WEB-сервер был написан на языке программирования Python, так как операционная система Armbian отлично подходит для работы с данным языком и позволяет взаимодействовать с GPIO выходами. Также на сервере в формате JSON хранятся записи о температурных режимах.
		\subsubsection{Python}
		Python - высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью. Данный язык ориентирован на повышение читаемости кода и качества его написания.Python является объектно ориентированным языком.
		
		Python применяется в различных сферах. Данный язык хорошо подходит как для маленьких разработок, так и для крупных проектов. Данная особенность обусловлена тем, что:
		\begin{itemize}
		\item язык гибкий и просто масштабируемый. Данный язык позволет разработчикам адаптировать высокоуровневую логику приложения, что позволяет легко расширять сложные приложения по мере необходимости;
		\item язык имеет большое количество готовых библиотек для решения конкретных типов задач. Ниже представлены библиотеки, которые были использованы для в выпускной квалификационной работе:
		\begin{itemize}
			\item spidev - библиотека для  работы с внрешними устройствами по протоколу SPI;
			\item smbus - библиотека для работы с внешними устройствами по протоколу I2C;
			\item pyA20 - библиотека для взаимодействия с GPIO выходами одноплатных микрокомпьютеров; 
			\item Flask - библиотека для разработки серверной части приложений;
		\end{itemize}
		\item поддержка модульности;
		\item кроссплатформенность;
		\end{itemize}
		Практически каждая организация, занимающаяся разработкой программного обеспечения, так или иначе использует Python как для решения долговременных, стратегических задач проектирования, так и для решения краткосрочных тактических задач, таких как тестирование и системное	администрирование. Такие известные компании, как Google и Intel, Cisco и	Hewlett-Packard, используют язык Python, выбрав его за гибкость, простоту	использования и обеспечиваемую им высокую скорость разработки. Он	позволяет создавать эффективные и надежные проекты, которые легко интегрируются с программами и инструментами, написанными на других
		языках.
		
		На Python были написаны скрипты для работы с одноплатным компьютером Orange Pi One для приема и обработки информации, поступающей с клиентской части приложения, а также для работы с электрическими частями устройств.
		
		Причинами выбора данного языка программирования можно считать:
		\begin{itemize}
		\item операционная система изначально поддерживала работу с данным языком программирования;
		\item для Python существует множество библиотек и фреймворков, позволяющих упростить выполнение поставленных задач;
		\end{itemize}		
		\subsubsection{Протокол SPI}
		SPI (Serial Perpheral Interface) - последовательный переферийный протокол обмена данными. Этот протокол был разработан компанией Motorola и в настоящие время используется многими производителями. Он предназначен для связи микроконтроллеров между собой, микроконтроллеров и переферийных устройств. 
		
		Для передачи данных в SPI используются три линии:
		\begin{itemize}
		\item MISO - по этой линии ведущий (Master) принимает данные от ведомого (Slave);
		\item MOSI - по этой линии ведущий отправляет данные ведомому;
		\item SCK - Эта линия служит для передачи тактового сигнала ведомому устройству;
		\end{itemize} 
		На рисунке \ref{re9} показано, как ведущее устройство взаимодействует с ведомым.
			\begin{figure}[!ht]
				\centering
				\includegraphics[scale=0.9]{9.jpg}
				\caption{\label{re9}%
		 Взаимодействие ведущего и ведомого устройства}
			\end{figure}
			
			В данной выпускной квалификационной работе бакалавра протокол SPI был использован для взаимодействия с аналого-цифровым преобразователем MAX6675, для считывания температуры с термопары. Использование протокола SPI обусловлено технологическими особенностями данного устройства.
		\subsubsection{Протокол I2C}
		I2C (Inter-Integrate Circuit) - последовательная шина данных для связи различных интегральных схем. Данный протокол использует двунаправленные линии связи SDA и SCL  для соединения низкоскоростных периферийных компонентов с микроконтроллером.
		
		Данный протокол разработан фирмой Philips в начале 1980-х как 8-битная шина внутренней связи для создания управляющей электроники.
		
		Для передачи данных в протоколе I2c используются две линии связи:
		\begin{itemize}
		\item SDA - последовательная линия данных;
		\item SCL - последовательная линия тактирования;
		\end{itemize}
		
		На рисунке \ref{re10} показано как по данному протоколу используя две линии связи передаются данные.
		\begin{figure}[!ht]
			\centering
			\includegraphics[scale=0.9]{10.jpg}
			\caption{\label{re10}%
Взаимодействие ведущего и ведомого устройства}
		\end{figure}
		
		На рисунке\ref{re11} показано, как ведущее устройство взаимодействует с ведомым.
		\begin{figure}[!ht]
			\centering
			\includegraphics[scale=0.9]{11.jpg}
			\caption{\label{re11}%
Взаимодействие ведущего и ведомого устройства}
		\end{figure}
		
		В данной выпускной квалификационной работе использование протокола I2C было связано с тем, что дисплей I2C 1602 LCD взаимодействует с одноплатным контроллером посредством данного протокола.
		\subsubsection{Библиотека pyA20}
		Данная библиотека предоставляет методы для управления выводами GPIO для Orange Pi One. Она написана для платы A20-OLinuXino-MICRO, но также может использоваться и с другими платами. 
		В функционале данной библиотеки доступны следующие методы:
		 \begin{itemize}
		 \item init() - произвести инициализацию модуля;
		 \item getcfg() - считать из устройства конфигурацию GPIO;
		 \item setcfg() - установить собственную конфигурацию GPIO;
		 \item input() - возвращает текущее значение на выходе GPIO;
		 \item output() - установить значение на выходе GPIO;
		 \item pullup() - установить подтягивающеее напряжение для логической еденицы или логического нуля;
		 \end{itemize}
		 Для установки различных значений для выходов GPIO доступны следующие контакты:
		 \begin{itemize}
		 \item HIGH - логическая еденица;
		 \item LOW - логический ноль;
		 \item OUTPUT - выход логической еденийы
		 \item PULLUP - тяга логической еденицы
		 \item  PULLDOWN - тяга логического нуля
		 \end{itemize}
		 
		 Ниже приведен простой пример использования данной библиотеки для вывода на выход GPIO PG7 логической еденицы:
 \begin{Verbatim}[fontsize=\small, numbers=left]
 from pyA20.gpio import gpio
 from pyA20.gpio import port
  
 gpio.init()
 gpio.setcfg(port.PG7, gpio.OUTPUT)
  
 gpio.output(port.PG7, gpio.HIGH)
 \end{Verbatim}
		 
		 В данном примере мы сначала из библиотеки pyA20 импортируем необходимые классы:
\begin{Verbatim}[fontsize=\small, numbers=left]
from pyA20.gpio import gpio
from pyA20.gpio import port
\end{Verbatim}
		 	Затем мы инициализируем модуль:
 \begin{Verbatim}[fontsize=\small, numbers=left]
 gpio.init()
 \end{Verbatim}
 		Дальше мы назначаем контакт PG7 как управляемый для выхода и подаем на него сигнал:
\begin{Verbatim}[fontsize=\small, numbers=left]
gpio.setcfg(port.PG7, gpio.OUTPUT)				  
gpio.output(port.PG7, gpio.HIGH)
\end{Verbatim}

		При использовании данной библиотеки каждый выход GPIO микроконтроллера имеет определенные названия представленные на рисунке \ref{re12}.
		\begin{figure}[!ht]
			\centering
			\includegraphics[scale=0.9]{12.jpg}
			\caption{\label{re12}%
Названия пинов микрокомпьютера Orange Pi One при работе с библиотекой pyA20}
		\end{figure}
		
		Данная библиотека была использована в выпускной квалификационной работе для взаимодействия с твердотельным реле. Плюсовой контакт реле был установлен в порт PG7, а минусовой на землю.
		\subsubsection{Библиотека Flask}
		Flask - фреймфорк для создания WEB-приложений на языке Python.  Flask отличается от других фреймворков тем, что позволяет разработчикам полностью контролировать свои приложения. Он поставляется с ядром, которое включает в себя весь необходимый функционал для работы WEB-приложений.
		
		Во Flask многие вещи предварительно сконфигурированы, на основе общей базовой конфигурации. Например, шаблоны и статические файлы сохранены в подкаталогах в пределах исходного дерева. 
		
		Flask имеет две основные особенности. Это подсистема маршрутизации, отладки и интерфейс WEB-сервера(WSGI) взяты из мощной библиотеки для веб-приложений под названием Werkzeug. Поддержка шаблонов обеспечивается при помощи популярного шаблонизатора Jinja2.
		
		В Flask нет встроенной поддержки для доступа к базам данных, проверки веб-форм, аутентификации пользователей или других задач высокого уровня. Эти и многие другие ключевые сервисы, которые необходимы большинству веб-приложений, доступны через расширения, которые интегрируются с основными пакетами. Программист может выбирать расширения, которые лучше всего подходят для проекта, или же писать свои
		собственные.
		
		Ниже приведен базовый пример использования данной библиотеки. 
\begin{Verbatim}[fontsize=\small, numbers=left]
from flask import Flask
app = Flask(name)

@app.route("/")
def hello():
  return "Hello World!"

if name == "main":
  app.run()
\end{Verbatim}
		Сначала мы импортируем Flask класс. Экземпляр этого класса будет нашим WSGI приложением. Первым аргументом является имя модуля приложения. Если вы используете один модуль (как в данном примере), вы должны использовать name, потому что в зависимости от того, было ли это начато как приложение или как импорт модуля, название будет другим ('main' по сравнению с реальным именем импорта).
\begin{Verbatim}[fontsize=\small, numbers=left]
from flask import Flask
\end{Verbatim}
		Далее мы создаем экземпляр этого класса. Мы передаем ему имя модуля или пакета. Это необходимо, так как Flask не знает, где искать шаблоны, статические файлы, и так далее.
\begin{Verbatim}[fontsize=\small, numbers=left]
app = Flask(name)
\end{Verbatim}
		Затем мы используем route(). Декоратор говорит Flask, что URL должен вызывать нашу функцию. 
\begin{Verbatim}[fontsize=\small, numbers=left]

@app.route("/")
\end{Verbatim}
		Функция задает имя, которое также используется для создания URL-адресов для этой функции, и возвращает сообщение, что мы хотим отобразить в браузере пользователя.
\begin{Verbatim}[fontsize=\small, numbers=left] 
def hello():
	return "Hello World!"
\end{Verbatim}
		Использую run() функцию для запуска локального сервера с нашим приложением. Условие name == «main» означает, что сервер работает только в том случае, если скрипт выполняется непосредственно из Python интерпретатора и не используется в качестве импортированного модуля.
\begin{Verbatim}[fontsize=\small, numbers=left]
if name == "main":
	app.run()
\end{Verbatim}

		Данная библиотека была использована в выпускной квалификационной работе для создания WEB-сервера.
	\subsubsection{JavaScript Object Notation}
JSON (JavaScript Object Notation) – формат для хранения и обмена данными.  Файлы JSON представляют собой более простую альтернативу формату м аналогичными функциями XML.

Существует два основных элемента объекта JSON: ключ и значения.
\begin{itemize}
\item ключи должны быть строками. Они содержат последовательность символов, которые заключены в кавычки;
\item значения являются допустимым типом данных JSON. Они могут быть в форме массива, объекта, строки, логического значения, числа или значения null;
\end{itemize}

Ниже представлен пример JSON объекта, хранящегося на сервере и использующийся для хранения значений, записанных из клиентской части, где ключ - номер цикла прокаливания, а значение состоит из массива, где первое значение - требуемая температура, а второе - время цикла работы устройства.
\begin{Verbatim}[fontsize=\small, numbers=left] 
{
   "1":[
      100,
      30
   ],
   "2":[
      200,
      30
   ]
}
\end{Verbatim}
	\subsection{Клиентская часть приложения}
	Клиентская часть WEB-приложения представляет собой сайт. Данный сайт имеет начальную страницу на которой из имеется вывод текущей температуры внутри муфельной печи, страницу текущего состояния, которая в реальном времени ввиде графика отображает процессы, происходящие внутри муфельной печи, страницу режимов работы муфельной печи.
		\subsubsection{Javascript}
		Изначально, данный зык программирования был создан для анимирования HTML страниц. Впоследствии, данный язык стал применяться в реализации сценариев WEB-страниц, таких как отправление запросов на сервер, обработку и вывод принимаемых данных с сервера.
		JavaScript запускается на стороне клиента, который может использоваться для создания и программирование того, как будет вести себя WEB-страница при наступлении каких-либо событий.
		К основным архитектурным чертам можно отнести:
		\begin{itemize}
		\item динамическая типизация;
		\item слабая типизация;
		\item автоматическое управление памятью;
		\item прототипное программирование;
		\item функции как объекты первого класса;
		\end{itemize}
		
		Для выпускной квалификационной работы был выбран данный язык в качестве взаимодействия с серверной частью приложения, обработка полученных данных.
		\subsubsection{HTML CSS}
		HTML (HyperText Markup Language) — стандартный язык разметки документов во Всемирной паутине. Большинство веб-страниц создаются при помощи языка HTML (или XHTML). Язык HTML интерпретируется браузерами и отображается в виде документа в удобной для человека форме.
		HTML представляет собой нобор так называемых <<тегов>>, описывающих структуру документа. Основные теги следующие:
		\begin{itemize}
		\item основные: html, head, title, body;
		\item структурны: div, span;
		\item текстовые: p, ul, li, h1-h6, b;
		\item таблицы: table, tr, td, th;
		\item ссылки: a;
		\item мультимедиа:img, object;
		\item формы: forom, input, label, select, option;
		\item специальные: script, link, meta
		\end{itemize}
		CSS (Cascading Style Sheets) — формальный язык описания внешнего вида документа, написанного с использованием языка разметки. Преимущественно используется как средство описания, оформления внешнего вида веб-страниц, написанных с помощью языков разметки HTML и XHTML, но может также применяться к любым XML-документам, например, к SVG или XUL.
		
		В выпускной квалификационной работе были использованы язык разметки язык стилей для создания WEB страниц.
		
\section{Разработка приложения}
В данном разделе будут описаны скрипты, используемые в серверной и клиентской частях приложения. А также будет описана структура HTML документов.
	\subsection{Серверная часть приложения}
	WEB-сервер был разработан на языке программирования Python. При разработке использовались библиотеки Flask - для создания WEB сервера, smbus - для работы с дисплеем I2C 1602a LCD посредством шины I2C, spidev - для работы с аналого-цифорвым преобразователем MAX6675 посредством шини SPI,  time - для корректной работы с временем, pyA20 - для работы с выходами  GPIO.
	
	Объявление импортированных библиотек выглядит следующим образом:
\begin{Verbatim}[fontsize=\small, numbers=left]
from flask import Flask, request, url_for, redirect, render_template
import spidev
import time
import smbus
from pyA20.gpio import gpio
from pyA20.gpio import port
\end{Verbatim}

После подключения всех библиотек  объявляем константы, необходимые для работы с дисплеем посредством шины I2C.

Подключаем дисплей I2C 1602A LCD по схеме к одноплатному микрокомпьютеру запускаем утилиту i2cdetect для определения адреса шины. Получем адрес 0x27.

Создаем константу:
\begin{Verbatim}[fontsize=\small, numbers=left]
I2C_ADDR  = 0x27
\end{Verbatim}

Далее создаем константы, определяющие максимальное количество символов в строке. В моем случае это 16.
\begin{Verbatim}[fontsize=\small, numbers=left]
LCD_WIDTH = 16
\end{Verbatim}

Создадим две константы обозначения отправления либо данных, либо команд.
\begin{Verbatim}[fontsize=\small, numbers=left]
LCD_CHR = 1 # Mode - Sending data
LCD_CMD = 0 # Mode - Sending command
\end{Verbatim}

Далее создадим константы адресов первой и второй строчки дисплея.
\begin{Verbatim}[fontsize=\small, numbers=left]
LCD_LINE_1 = 0x80 # LCD RAM address for the 1st line
LCD_LINE_2 = 0xC0 # LCD RAM address for the 2nd line
\end{Verbatim}

Далее мы открываем для считывания и записи I2C интерфейс командой:
\begin{Verbatim}[fontsize=\small, numbers=left]
bus = smbus.SMBus(0) 
\end{Verbatim}

После предварительных настроек создаем экземпляр класса Flask. Мы передаем ему имя модуля. Это необходимо, так как Flask не знает, где искать шаблоны, статические файлы, и так далее.
\begin{Verbatim}[fontsize=\small, numbers=left]
app = Flask(temperature_controller) 
\end{Verbatim}

Опишем роугинг, созданный для открытия HTML страниц.
\begin{Verbatim}[fontsize=\small, numbers=left]
@app.route("/", methods=['POST', 'GET'])
def index():
    return render_template("index.html")
\end{Verbatim}
В данной части при GET запросе на стороне клиента будет отправлена стартовая страница сайта.

\begin{Verbatim}[fontsize=\small, numbers=left]
@app.route("/modes", methods=['POST', 'GET'])
def modes():
    if request.method == 'POST':
        return redirect(url_for('modes'))
    return render_template("modes.html")
\end{Verbatim}

В данной части при POST или GET запросе на стороне клиента будет отправлена страница  режимов работы сайта.

\begin{Verbatim}[fontsize=\small, numbers=left]
@app.route("/graph", methods=['POST', 'GET'])
def graph():
    if request.method == 'POST':
        return redirect(url_for('graph'))
    return render_template("graph.html")
\end{Verbatim}

В данной части кода при POST или GET запросе на стороне клиента будет отправлена страница  текущего состояния сайта.

Следующей разработанной функцией является функция для взятия температуры с термопары. мной был объявлен декоратор route() со значением temperature. При отправке со стороны клиента по адресу с /temperature, ответом от сервера будет текущая температура внутри муфельной печи или, если произошел обрыв термопары, то ответом будет <<Термопара не подключена>>.

\begin{Verbatim}[fontsize=\small, numbers=left]
@app.route("/temperature", methods=['POST', 'GET'])
def temperature():
    temp = temperatureCheck()
    if temp <= 1:
        return ("Термопара не подключена")
    else:
        return (str(temp))
\end{Verbatim}

В данной части кода я вызываю написанную мной функцию temperatureCheck() которая выглядит следующим образом:
\begin{Verbatim}[fontsize=\small, numbers=left]
def temperature_check():
    spi = spidev.SpiDev()
    spi.open(0,0)
    resp = spi.readbytes(2)
    temp = ((resp[1] + resp[0]*256)/8)*0.25
    return temp
\end{Verbatim}

Значение температуры мы берем из протокола SPI по 2 байта и преобразуем данные значения в градусы Цельсия.

Следующая функция необходима для считывания установленных температурных полок из полученного с клиентской части JSON объекта. Так же она записывает данные из  JSON объекта в файл для последующего воспроизведения температурных установок на микрокомпьютере и запускает функцию работы с дисплеем и термопарой. Далее, она загружает страницу <<текущего состояния>> для отслеживания корректной работы устройства.
\begin{Verbatim}[fontsize=\small, numbers=left]
@app.route("/start_record", methods=['POST', 'GET'])
def start_record():
    if request.method == 'POST':
        f = open('temperature_mode.txt', 'w')
        i = 1
        for data in request.get_json():
            if i == 2:
                i = 1
                f.write(data + '\n')
            else:
                i += 1
                f.write(data + ' ')
        f.close()
    start_working()
    return render_template("graph.html")
\end{Verbatim}

В данной части кода вызывается функция StartWorking(), которая запускает работу дисплея а также считывает первую температурную полку из созданного файла и вызывает функцию работы с конкретной температурной полкой. Данная функция выглядит следующим образом:
\begin{Verbatim}[fontsize=\small, numbers=left]
def start_working():
    lcd_byte(0x01, LCD_CMD)
    records = []
    with open("temperature_mode.txt", "r") as f:
        for line in f.readlines():
            records.append(line)
    while (records):
        cur_mode(records.pop(0))
\end{Verbatim}

Функция работы с текущей температурной полкой выглядит следующим образом:
\begin{Verbatim}[fontsize=\small, numbers=left]
def cur_mode(line):
    lst = line.split()
    temperature = int(lst[0])
    time_set = int(lst[1])

    lcd_init()

    signal = port.PG7
    gpio.init()
    gpio.setcfg(signal, gpio.OUTPUT)

    while (time_set):
        minute = 60
        while (minute):
            cur_temperature = temperature_check()
            lcd_string("SET" + "{}".format(temperature),LCD_LINE_1)
            lcd_string("CUR" + "{}".format(cur_temperature),LCD_LINE_2)
            if cur_temperature < temperature:
                gpio.output(signal, 1)
            else:
                gpio.output(signal, 0)
                minute = minute - 1
            time.sleep(1)
        time_set = time_set - 1
\end{Verbatim}

В данной функции мы сначала объявляем две переменные, которые в дальнейшем будут выводится на дисплей. 
\begin{Verbatim}[fontsize=\small, numbers=left]
    lst = line.split()
    temperature = int(lst[0])
    time_set = int(lst[1])
\end{Verbatim}

 Следующим нашим действием мы вызываем функцию lcdInit, которая инициализирует настройки дисплея.
 \begin{Verbatim}[fontsize=\small, numbers=left]
def lcd_init():
    # Initialise display
    lcd_byte(0x33,LCD_CMD) # 110011 Initialise
    lcd_byte(0x32,LCD_CMD) # 110010 Initialise
    lcd_byte(0x06,LCD_CMD) # 000110 Cursor move direction
    lcd_byte(0x0C,LCD_CMD) # 001100 Display On,Cursor Off, Blink Off 
    lcd_byte(0x28,LCD_CMD) # 101000 Data length, number of lines, font size
    lcd_byte(0x01,LCD_CMD) # 000001 Clear display
    time.sleep(E_DELAY)
 \end{Verbatim}
 
 Далее мы инициализируем порт PG7 для взаимодействия с твердотельным реле.
  \begin{Verbatim}[fontsize=\small, numbers=left]
    signal = port.PG7
    gpio.init()
    gpio.setcfg(signal, gpio.OUTPUT)
  \end{Verbatim}
  
  Дальше мы создаем цикл, в котором обрабатываем время, которое было передано для текущей температурной настройки. Так же проверяем каждую секунду изменения температуры функцией temperatureCheck() если температура ниже необходимой. подаем сигнал на твердотельное реле, если же температура достаточная или же выше требуемой, останавливаем подачу сигнала. Также данная часть кода отправляет в функцию печати на дисплей - lcdString, которая будет описана позже, значения текущей температуры и температуры заданной температурной полкой.
\begin{Verbatim}[fontsize=\small, numbers=left]
    while (time_set):
        minute = 60
        while (minute):
            cur_temperature = temperature_check()
            lcd_string("SET " + "{}".format(temperature),LCD_LINE_1)
            lcd_string("CUR " + "{}".format(cur_temperature),LCD_LINE_2)
            if cur_temperature < temperature:
                gpio.output(signal, 1)
            else:
                gpio.output(signal, 0)
                minute = minute - 1
            time.sleep(1)
        time_set = time_set - 1
\end{Verbatim}

Функция вывода необходимых строк выглядит следующим образом:
\begin{Verbatim}[fontsize=\small, numbers=left]
def lcd_string(message,line):
    # Send string to display

    message = message.ljust(LCD_WIDTH," ")

    lcd_byte(line, LCD_CMD)

    for i in range(LCD_WIDTH):
        lcd_byte(ord(message[i]),LCD_CHR)
\end{Verbatim}

Данная функция на вход получает строку, которую нужно вывести и номер строки (1 или 2) для вывода на дисплей.

Далее Использую run() функцию для запуска локального сервера с моим приложением. Условие name == «main» означает, что сервер работает только в том случае, если скрипт выполняется непосредственно из Python интерпретатора и не используется в качестве импортированного модуля. 

\begin{Verbatim}[fontsize=\small, numbers=left]
if temperature_controller == "__main__":
    app.run(host='0.0.0.0', port=80, debug=True)
\end{Verbatim}
Полный код приведен в Приложении А, листинг <<server.py>>
	\subsection{Клиентская часть приложения}
		\subsubsection{Начальная страница}
		\subsubsection{Страница текущего состояния}
		\subsubsection{Страница режимов работы}
	
		







% Раздел "Заключение"
\conclusion

%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix




\end{document}
